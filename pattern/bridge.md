# Мост: Bridge
## 1. Название и классификация
Тип паттерна: структурный шаблон проектирования. Известен также под именем
Handle/Body (описатель/тело).
Мост — это паттерн, структурирующий объекты, который разделяет 1 или несколько классов на абстракцию и реализацию, позволяя изменять их независимо.
## 2. Назначение
каковы функции паттерна,
его обоснование и назначение,
какую конкретную задачу проектирования он позволяет решить.
Назначение
Отделить абстракцию от ее реализации так, чтобы то и другое можно было изменять независимо.
Задача 
Класс геометрических Фигур имеет подклассы Круг и Квадрат. Вы хотите расширить классы фигур сразу в двух независимых плоскостях — по виду и по цвету. Придётся создать комбинации подклассов, например СиниеКруги и КрасныеКвадраты.

Количество подклассов растёт в геометрической прогрессии.

 Решение

Паттерн Мост предлагает заменить наследование агрегацией или композицией. 
Решение паттерна Мост
Размножение подклассов можно остановить, разбив классы на несколько иерархий.

Можно сделать Цвет отдельным классом с подклассами Красный и Синий. Класс Фигур получит ссылку на объект Цвета и сможет делегировать ему работу, если потребуется. Такая связь и станет мостом между Фигурами и Цветом.

## 3. Мотивация использования. Сценарий, иллюстрирующий задачу проектирования и то, как она решается данной структурой класса или объекта.
![](https://github.com/Meao/py/blob/master/pattern/mot.png)
Абстракция и Реализация

Абстракция (или интерфейс) — это образный слой управления чем-либо. Он делегирует работу слою реализации (иногда называемому платформой).

Абстракцией может выступать графический интерфейс программы (GUI), а реализацией — низкоуровневый код операционной системы (API).

Мост позволит развивать программу в двух разных направлениях:

несколько GUI (для пользователей и администраторов);
много API (Windows, Linux и MacOS).


Вы можете попытаться структурировать программу, создав для каждой пары интерфейса-платформы подклассы. Но такой подход приведёт к росту классов комбинаций.

Паттерн Мост предлагает разделить код на две части:

Абстракцию: слой графического интерфейса приложения.
Реализацию: слой взаимодействия с операционной системой.

Вариант кросс-платформенной архитектуры

Абстракция будет делегировать работу одному из объектов реализаций. Реализации можно будет взаимозаменять, если они будут следовать общему интерфейсу.
![](https://github.com/Meao/py/blob/master/pattern/motextdn.png)
## 4. Применимость. Описание ситуаций, в которых паттерн можно применять. Примеры проектирования, которые можно улучшить, используя данный паттерн.

 Главная задача — структурная. Разделить слишком большой класс, который содержит несколько различных реализаций какой-то функциональности (например, работа с разными системами баз данных).

Это упрощает работу над кодом и уменьшает вероятность внесения ошибок.

 Когда и абстракции, и реализации должны расширяться новыми подклассами. В таком случае паттерн мост позволяет комбинировать разные абстракции и реализации и изменять их независимо. Нужно будет создать ссылку на один из объектов в первоначальном классе.

 Когда вы хотите избежать постоянной привязки абстракции к реализации. Изменения в реализации абстракции не должны сказываться на клиентах, то есть клиентский код не должен перекомпилироваться. Мост позволяет менять реализацию во время выполнения программы, так как конкретная реализация не «вшита» в класс абстракции.
 
 ## 5. Структура. Графическое представление классов в паттерне с использованием нотации OMT
![](https://github.com/Meao/py/blob/master/pattern/strpy.png)
Структура классов паттерна Мост
Абстракция содержит управляющую логику. Код абстракции делегирует  работу связанному объекту реализации.

Реализация задаёт общий интерфейс для всех реализаций. Все методы, которые здесь описаны, доступны из класса и подклассов абстракции.

Обычно в реализации хранятся базовые операции, на которых строятся сложные операции абстракции.

Конкретные реализации содержат платформо-зависимый код.

Расширенные абстракции содержат вариации управляющей логики. Как и родитель, работает с реализациями только через общий интерфейс реализации.

Клиент работает только с объектами абстракции. Клиентский код имеет прямой доступ исключительно в процессе начального связывания абстракции с одной из реализаций.
![](https://github.com/Meao/py/blob/master/pattern/struex.png)

## 6. Участники: классы, объекты, использующиеся в данном паттерне и их функции
Abstraction (Window) – абстракция:
– определяет интерфейс абстракции;
– хранит ссылку на объект типа Implementor;
RefinedAbstraction (IconWindow) – уточненная абстракция:
– расширяет интерфейс, определенный абстракцией Abstraction;
Implementor (WindowImp) – реализатор:
– определяет интерфейс для классов реализации. Он не обязан точно соответствовать интерфейсу класса Abstraction. На самом деле оба интерфейса могут быть совершенно различны. Обычно интерфейс класса Implementor предоставляет только примитивные операции, а класс Abstraction определяет операции более высокого уровня, базирующиеся на этих примитивах;
ConcreteImplementor (XWindowImp, PMWindowImp) – конкретный реализатор:
– содержит конкретную реализацию интерфейса класса Implementor.
 Шаги реализации

Определить, есть ли в классах 2 непересекающихся измерения. Примеры: функциональность/платформа, предметная-область/инфраструктура, фронт-энд/бэк-энд, интерфейс/реализация.

Выделить, какие операции будут нужны клиентам, и описать их в базовом классе абстракции.

Определить поведения, доступные на всех платформах, и выделить из них часть, которая нужна абстракции. На основании этого описать общий интерфейс реализации.

Для каждой платформы создать свой класс реализации.
## 7. Отношения. Описание взаимодействия между участниками для выполнения своих функций
Добавить в класс абстракции ссылку на объект реализации. Реализовать методы абстракции, делегируя основную работу связанному объекту реализации.

Для каждой из вариаций абстракций создать свой подкласс.

Клиент должен подать объект реализации в конструктор абстракции, чтобы связать их. После этого он может работать с объектом абстракции.
Объект Abstraction перенаправляет своему объекту Implementor запросы клиента.
## 8. Результаты:
насколько паттерн удовлетворяет поставленным требованиям?
результаты применения, компромиссы, на которые приходится идти;
какие аспекты поведения системы можно независимо изменять, используя данный паттерн?
 Преимущества 

- Позволяет строить платформо-независимые программы.
- Скрывает лишние или опасные детали реализации от клиентского кода.
- Реализует принцип открытости/закрытости.
Недостатки
- Усложняет код программы из-за введения дополнительных классов.

## 9. Реализация, имплементация на Python: сложности и подводные камни советы и рекомендуемые приемы
Особенности паттерна на Python
- только один класс Implementor. 
- создание правильного объекта Implementor. Как, когда и где принимается решение о том, какой из нескольких классов Implementor инстанцировать? Если у класса Abstraction есть информация о конкретных классах ConcreteImplementor, то он может инстанцировать один из них в своем конструкторе.
- разделение реализаторов.
- использование множественного наследования. 
Этот пример показывает структуру паттерна Мост — из каких классов он состоит, какие роли они выполняют, как они взаимодействуют друг с другом.
![](https://github.com/Meao/py/blob/master/pattern/strpy.png)

 main.py: Пример структуры паттерна

```python 
from __future__ import annotations
from abc import ABC, abstractmethod


class Abstraction:
    """
    Абстракция устанавливает интерфейс для «управляющей» части двух иерархий
    классов. Она содержит ссылку на объект из иерархии Реализации и делегирует
    ему работу.
    """

    def __init__(self, implementation: Implementation) -> None:
        self.implementation = implementation

    def operation(self) -> str:
        return (f"Абстракция: Базовая операция с:\n"
                f"{self.implementation.operation_implementation()}")


class ExtendedAbstraction(Abstraction):
    """
    Можно расширить Абстракцию без изменения классов Реализации.
    """

    def operation(self) -> str:
        return (f"Расширенаня абстракция: Расширенаня операция с:\n"
                f"{self.implementation.operation_implementation()}")


class Implementation(ABC):
    """
    Реализация устанавливает интерфейс для всех классов реализации. Как правило, интерфейс Реализации предоставляет только
    примитивные операции, в то время как Абстракция определяет операции более
    высокого уровня, основанные на этих примитивах.
    """

    @abstractmethod
    def operation_implementation(self) -> str:
        pass


"""
Каждая Конкретная Реализация соответствует определённой платформе и реализует
интерфейс Реализации с использованием API этой платформы.
"""


class ConcreteImplementationA(Implementation):
    def operation_implementation(self) -> str:
        return "Конкретная реализация 1: Результат на платформе A."


class ConcreteImplementationB(Implementation):
    def operation_implementation(self) -> str:
        return "Конкретная реализация 2: Результат на платформе B."


def client_code(abstraction: Abstraction) -> None:
    """
    За исключением этапа инициализации, когда объект Абстракции связывается с
    определённым объектом Реализации, клиентский код должен зависеть только от
    класса Абстракции. Таким образом, клиентский код может поддерживать любую
    комбинацию абстракции и реализации.
    """

    

    print(abstraction.operation(), end="")

    


if __name__ == "__main__":
    """
    Клиентский код должен работать с любой предварительно сконфигурированной
    комбинацией абстракции и реализации.
    """

    implementation = ConcreteImplementationA()
    abstraction = Abstraction(implementation)
    client_code(abstraction)
    print("\n")

    implementation = ConcreteImplementationB()
    abstraction = ExtendedAbstraction(implementation)
    client_code(abstraction)
    print("\n")

    implementation = ConcreteImplementationA()
    abstraction = ExtendedAbstraction(implementation)
    client_code(abstraction)
    print("\n")

    implementation = ConcreteImplementationB()
    abstraction = Abstraction(implementation)
    client_code(abstraction)
```
[Результат выполнения](https://repl.it/@MarinaKrvtsn/InsecureConsiderableLock#main.py)
```
Абстракция: Базовая операция с:
Конкретная реализация 1: Результат на платформе A.

Расширенаня абстракция: Расширенаня операция с:
Конкретная реализация 2: Результат на платформе B.

Расширенаня абстракция: Расширенаня операция с:
Конкретная реализация 1: Результат на платформе A.

Абстракция: Базовая операция с:
Конкретная реализация 2: Результат на платформе B.
```
## 10. Известные применения. Возможности применения паттерна в реальных системах.

 Паттерн Мост особенно полезен когда надо делать кросс-платформенные приложения, поддерживать несколько типов баз данных или работать с разными поставщиками похожего API (например, cloud-сервисы, социальные сети и т. д.)
PyObjC является двунаправленным мостом между Python и Objective-C, что позволяет писать программное обеспечение OSX в Python. PyObjC — проект, позволяющий совместно использовать библиотеки и классы таких языков программирования, как Python и Objective-C. Даёт доступ из Python к Cocoa, включает поддержку Xcode, хорошо документирован и снабжён многочисленными примерами.
Модуль достиг стабильности. 
## 11. Родственные паттерны. Важные различия. Использование данного паттерна в сочетании с
другими.
 Отношения с другими паттернами

Мост, Стратегия и Состояние имеют схожие структуры классов — они построены на принципе «композиции», то есть делегирования работы другим объектам. Они отличаются тем, что решают разные проблемы.
Для обеспечения совместной работы не связанных между собой классов прежде всего предназначен паттерн адаптер. Обычно он применяется в уже готовых системах. Мост же участвует в проекте с самого начала и призван поддержать возможность независимого изменения абстракций и их реализаций.

Паттерн абстрактная фабрика может создать и сконфигурировать мост.
Абстрактная фабрика может работать совместно с Мостом. Это особенно полезно, если у вас есть абстракции, которые могут работать только с некоторыми из реализаций. В этом случае фабрика будет определять типы создаваемых абстракций и реализаций.

Паттерн Строитель может быть построен в виде Моста: директор будет играть роль абстракции, а строители — реализации.
