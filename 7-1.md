Асинхронный Python

Определение терминов:

Синхронный и асинхронный:
В синхронных операциях задачи выполняются друг за другом. В асинхронных задачи могут запускаться и завершаться независимо друг от друга. 

Конкурентность и параллелизм:
Конкурентность подразумевает, что две задачи выполняются совместно. 
Параллелизм является формой конкурентности. Но зависит от оборудования, если в CPU только одно ядро, то две задачи не могут выполняться параллельно. 

Подытожим:
Синхронность: блокирует операции (блокирующие)
Асинхронность: не блокирует операции (неблокирующие)
Конкурентность: совместный прогресс (совместные)
Параллелизм: параллельный прогресс (параллельные)
Параллелизм подразумевает конкурентность. Но конкурентность не всегда подразумевает параллелизм.

Потоки и процессы

Потоки позволяют выполнять операции конкурентно. Global Interpreter Lock (GIL) - потоки не могли обеспечить настоящий параллелизм. С появлением multiprocessing можно использовать несколько ядер с помощью Python.

Потоки (Threads):
pymotw.com/3/threading/index.html

Global Interpreter Lock (GIL)

Одновременно может выполняться один поток.
Интерпретатор Python переключается между потоками для достижения конкурентности. Для CPU зависимых задач интерпретатор делает проверку каждые N тиков и переключает потоки. Таким образом один поток не блокирует другие. Операциям ввода/вывода GIL обычно не мешает.
GIL применим к CPython. Но, например, Jython и IronPython не имеют GIL.
GIL делает однопоточные программы быстрыми.
GIL позволяет легко интегрировать непотокобезопасные библиотеки на C, благодаря GIL есть много высокопроизводительных библиотек, NumPy, SciPy.
GIL:
www.dabeaz.com/python/UnderstandingGIL.pdf

Процессы (Processes)

Чтобы достичь параллелизма в Python был добавлен модуль multiprocessing, который предоставляет API, похож на threading. multiprocessing использует Процесс вместо Потока.

Дальнейшее чтение о multiprocessing:
pymotw.com/3/multiprocessing/index.html

Модуль concurrent.futures

Модуль concurrent.futures позволяет писать асинхронный код очень легко. исполнители ThreadPoolExecutor и ProcessPoolExecutor поддерживают пул потоков или процессов. Мы отправляем наши задачи в пул, и он запускает задачи в доступном потоке / процессе. Возвращается объект Future, который можно использовать для запроса и получения результата по завершении задачи.

Дальнейшее чтение о concurrent.futures:
pymotw.com/3/concurrent.futures

Asyncio 

Процессы очень дорогостоящие для создания с точки зрения потребления ресурсов. Поэтому для операций ввода/вывода в основном выбираются потоки. 
ввод-вывод зависит от внешних вещей — медленные диски или сетевые лаги делают ввод-вывод непредсказуемым.

Asyncio предоставляет цикл событий. Цикл событий (event loop) — программная конструкция, которая ожидает прибытия и производит рассылку событий или сообщений в программе, отслеживает события ввода/вывода и переключает задачи, которые готовы и ждут операции ввода/вывода.

Asyncio использует генераторы и корутины для остановки и возобновления задач:
masnun.com/2015/11/20/python-asyncio-future-task-and-the-event-loop.html
masnun.com/2015/11/13/python-generators-coroutines-native-coroutines-and-async-await.html

Делаем правильный выбор

Только что мы прошлись по самым популярным формам конкурентности. Но остаётся вопрос — что следует выбрать? Это зависит от вариантов использования. Можно следовать этому псевдо-коду:

if io_bound:
    if io_very_slow:
        print("Use Asyncio")
    else:
       print("Use Threads")
else:
    print("Multi Processing")

CPU Bound => Multi Processing
I/O Bound, Fast I/O, Limited Number of Connections => Multi Threading
I/O Bound, Slow I/O, Many connections => Asyncio
